.data
MSG_FULL: .asciiz "Acumulador Cheio"           # 17 bytes, pad 3
.align 3
str_nl:   .asciiz "\n"                           # 2 bytes, pad 2

.text
.globl main

# ---------------------------------------------------------
# ROTINA PRINCIPAL (MAIN)
# ---------------------------------------------------------
main:
    	# --- Alocar acumulador (global) ---
    	# 1 palavra (4 bytes) para o contador (N)
    	# 4 palavras (16 bytes) para os 4 floats
    	# Total = 5 palavras = 20 Bytes
    	addi   $v0, $zero, 9     # syscall 9 (sbrk)
    	addi   $a0, $zero, 44    # Alocar 20 bytes
    	syscall
    	add  $s0, $v0, $zero   # Salva o endereco base do acumulador em $s0
    	sw    $zero, 0($s0)	# Inicializa o contador N em 0

	addi $t9, $zero, 10
    	READ_LOOP_MAIN:
    		beq $t9, $zero, AFTER_READS
    		ori   $v0, $zero, 6     # syscall 6 (read_float)
    		syscall
    		mov.s $f12, $f0         # argumento para a função de inserção
    		jal   INSERT_ACCUMULATOR_FLOAT
		addi $t9, $t9, -1
    		j READ_LOOP_MAIN
	AFTER_READS:
    
    	# --- Chamar a funcao de Desvio Padrao ---
    	# A funcao agora usa $s0 (acumulador) implicitamente
    	jal   CALCULA_DESVIO_PADRAO
    	# O resultado (float) estao em $f0
    
    	# Imprime o desvio padrao
    	mov.s $f12, $f0
    	ori   $v0, $zero, 2
    	syscall

    	# --- Encerrar o programa ---
    	addi   $v0, $zero, 10
    	syscall
END_MAIN:

#===========================================================
# FUNCAO PARA INSERIR FLOAT NO ACUMULADOR
# Argumentos: $f12 (float a inserir), $s0 (acumulador global)
#===========================================================
INSERT_ACCUMULATOR_FLOAT:
	# Guardar $s1 e $fp na pilha
	sw $s1, 0($sp)	# Guarda $s1 em sp[0]
	
	# Ajustar pilha para guardar mais informacoes
	addi $sp, $sp, -4
	
	# Avaliacao da expressao
	lw    $s1, 0($s0)       # $t0 = N (contador atual)
	slti  $t1, $s1, 10       # Verifica se N < 10  (limite do nosso array - 10 floats)
	beq   $t1, $zero, INSERT_ACCUMULATOR_ELSE
	
	# Calculo do deslocamento
	addi $t1, $zero, 4	# $t1 = 4 (bytes por float)
	mul $t2, $s1, $t1	# $t0 * $t1 (N * 4)
	addi $t2, $t2, 4     	# $t2 = offset + 4 (pula o contador)
	add  $t2, $t2, $s0	# $t2 = Endereco Base + offset + 4
	
	# Guarda o valor no acumulador
	swc1  $f12, 0($t2)    # Salva o float no endereco
	addi $s1, $s1, 1	# N++
	sw    $s1, 0($s0)	# Salva o novo N
	
	# Pula para o final da condicao
	beq   $zero, $zero, INSERT_ACCUMULATOR_END_IF
	
	INSERT_ACCUMULATOR_ELSE: # Acumulador cheio
		# Obter string para informar acumulador cheio
		# la $a0, MSG_FULL
		lui $a0, 0x1001
		ori $a0, $a0, 0			# Offset 0 (MSG_FULL)
		addi   $v0, $zero, 4		# syscall para imprimit string
		syscall

		# Obter quebra de linha
		addi $a0, $zero, 10		# Codigo do caractere nova linha
		addi   $v0, $zero, 11
		syscall
		
	INSERT_ACCUMULATOR_END_IF:
		# Recuperar dados da pilha antes de retornar
		lw $s1, 4($sp)	# Obtem de volta o antigo $s1
		addi $sp, $sp, 4	# Retorna $sp para o endereco correto
	
		# Retorna para o chamados
		jr $ra
END_INSERT_ACCUMULATOR_FLOAT:

#===========================================================
# FUNCAO PARA LIMPAR O ACUMULADOR
#===========================================================
CLEAR_ACCUMULATOR:
	sw $zero, 0($s0)
	jr $ra
END_CLEAR_ACCUMULATOR:

#==========================================================================
# FUNCO DE MEDIA
#==========================================================================
# Argumentos:
#   $s0 - (Global) Ponteiro para o Acumulador
# Retorno:
#   $f0 - Media (float)
#==========================================================================
CALCULA_MEDIA:
    	# --- Guardar Registradores que serao usados ---
    	sw    $ra, 0($sp)      # Salva endereco de retorno
    	sw    $s1, 4($sp)       # Salva $s1 (N)
    	sw    $s2, 8($sp)       # Salva $s2 (contador i)
    	swc1  $f1, 12($sp)       # Salva $f1 (Soma)
    	addi $sp, $sp, -16

    	# --- Inicializacao ---
    	lw    $s1, 0($s0)       # $t1 = N (contador de notas)
    	addu  $s2, $zero, $zero # $s2 = i = 0
	mtc1  $zero, $f1        # $f1 = Soma = 0.0

	CALC_MEDIA_LOOP:
		# --- Condicao de Loop: if (i >= N) sai ---
		slt   $t2, $s2, $s1     # $t2 = 1 se (i < N)
		beq   $t2, $zero, CALC_MEDIA_LOOP_END

		# --- Corpo do Loop ---
		# Calcular endereco da nota: &acumulador[i+1]
		addi $t3, $s2, 1       # $t3 = i + 1
		ori   $t4, $zero, 4     # $t4 = 4 (bytes)
		mult  $t3, $t4
		mflo  $t3               # $t3 = (i+1) * 4
		addu  $t3, $s0, $t3     # $t3 = Endereco Base + Offset

		# Carregar a nota
    		lwc1  $f2, 0($t3)       # $f2 = nota[i]
    
    		# Acumular soma
    		add.s $f1, $f1, $f2     # Soma = Soma + nota[i]

    		# --- Incremento ---
    		addiu $s2, $s2, 1       # i++
    		beq   $zero, $zero, CALC_MEDIA_LOOP
	CALC_MEDIA_LOOP_END:
    
    	# --- Divisao ---
    	# Converter N (inteiro em $t1) para N (float em $f2)
    	mtc1  $t1, $f2
    	cvt.s.w $f2, $f2
    
    	# $f0 = Soma / N
    	div.s $f0, $f1, $f2     # $f0 o registrador de retorno

	# --- Recuperar Dados ---
	addi $sp, $sp, 16
	lw    $ra, 0($sp)
	lw    $s1, 4($sp)
	lw    $s2, 8($sp)
        lwc1  $f1, 12($sp)

    	jr $ra	# Retorna para o chamador

FIM_CALCULA_MEDIA:

#==========================================================================
# FUNCAO DE DESVIO PADRAO (AMOSTRAL, N-1)
#==========================================================================
# Argumentos:
#   $s0 - (Global) Ponteiro para o Acumulador
# Retorno:
#   $f0 - Desvio Padrao (float)
#==========================================================================
CALCULA_DESVIO_PADRAO:
    	# --- Guardar Registradores que serao usados ---
    	addiu $sp, $sp, -40
    	sw    $ra, 36($sp)      # Salva retorno
    	swc1  $f20, 20($sp)     # Salva $f20 (Media)
    	swc1  $f25, 0($sp)      # Salva $f25 (Soma dos Quadrados)
    	sw    $s1, 32($sp)      # Salva $s1 (N)
    	sw    $s2, 28($sp)      # Salva $s2 (contador i)
    	# (Nao precisamos salvar $f21-f24 pois agora lemos em loop)

    	# --- Carregar N ---
    	lw    $s1, 0($s0)       # $s1 = N (contador)

	# --- Passo 1: Chamar 'CALCULA_MEDIA' ---
    	# A funcao CALCULA_MEDIA usa $s0 (global)
    	jal   CALCULA_MEDIA
    	# A media retorna em $f0
    	mov.s $f20, $f0         # Salva a media em $f20

    	# --- Passo 2: Calcular a soma dos quadrados das diferencas: Î£(xi - Î¼)Â² ---
    	addu  $s2, $zero, $zero # i = 0
    	mtc1  $zero, $f25       # SomaQuadrados = 0.0

	DESVIO_LOOP:
    	# --- Condicao de Loop: if (i >= N) sai ---
    	slt   $t2, $s2, $s1     # $t2 = 1 se (i < N)
    	beq   $t2, $zero, DESVIO_LOOP_END
    
    	# --- Corpo do Loop ---
    	# Calcular endereco da nota: &acumulador[i+1]
    	addiu $t3, $s2, 1       # $t3 = i + 1
    	ori   $t4, $zero, 4     # $t4 = 4 (bytes)
   	mult  $t3, $t4
    	mflo  $t3               # $t3 = (i+1) * 4
    	addu  $t3, $s0, $t3     # $t3 = Endereco Base + Offset

    	# Carregar a nota
    	lwc1  $f1, 0($t3)       # $f1 = nota[i]

    	# Calcular (nota[i] - Î¼)
    	sub.s $f2, $f1, $f20    # $f2 = nota[i] - Î¼
    
    	# Calcular (nota[i] - Î¼)Â²
    	mul.s $f2, $f2, $f2     # $f2 = (nota[i] - Î¼)Â²
    
    	# Acumular soma
    	add.s $f25, $f25, $f2   # SomaQuadrados += (nota[i] - Î¼)Â²

    	# --- Incremento ---
    	addiu $s2, $s2, 1       # i++
    	beq   $zero, $zero, DESVIO_LOOP
	DESVIO_LOOP_END:
    
    	# $f25 agora contem a Soma dos Quadrados
    
    	# --- Passo 3: Calcular a Variancia Amostral (Soma / (N-1)) ---
    
    	# Calcular N-1
    	addiu $t0, $s1, -1      # $t0 = N - 1
    
	mtc1  $t0, $f1          # Move (N-1) para o coprocessador
	cvt.s.w $f1, $f1        # Converte (N-1) para float
    
    	# $f25 = SomaQuadrados / (N-1)
    	div.s $f25, $f25, $f1   # $f25 = Variancia Amostral
    
    	# --- Passo 4: Calcular o Desvio Padrao (Raiz da Variancia) ---
    	sqrt.s $f0, $f25        # $f0 = Desvio Padrao (retorno)

    	# --- EpÃ­logo ---
    	lw    $s2, 28($sp)
    	lw    $s1, 32($sp)
    	lwc1  $f25, 0($sp)
    	lwc1  $f20, 20($sp)
    	lw    $ra, 36($sp)
    	addiu $sp, $sp, 40

    	jr $ra
FIM_CALCULA_DESVIO_PADRAO:
